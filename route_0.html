<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸Šæµ·é€šå‹¤è·¯çº¿è§„åˆ’</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }

        header {
            background: linear-gradient(90deg, #4b6cb7 0%, #182848 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }

        h1 {
            font-size: 2.2em;
            margin-bottom: 10px;
        }

        .info-section {
            padding: 15px 20px;
            background: #f8f9fa;
            border-bottom: 2px solid #e9ecef;
        }

        .info-section p {
            margin: 5px 0;
            font-size: 1.1em;
        }

        .transport-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            padding: 20px;
            background: #f8f9fa;
        }

        .transport-btn {
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .transport-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .transport-btn.active {
            background: linear-gradient(45deg, #28a745, #20c997);
        }

        .routes-container {
            padding: 20px;
            background: white;
        }

        .route-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .route-btn {
            padding: 15px;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
        }

        .route-btn:hover {
            border-color: #4b6cb7;
            background: #f8f9ff;
        }

        .route-btn.selected {
            border-color: #4b6cb7;
            background: #4b6cb7;
            color: white;
        }

        .route-details {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .route-info {
            margin: 10px 0;
            padding: 15px;
            background: white;
            border-radius: 8px;
            border-left: 4px solid #4b6cb7;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            padding: 5px 0;
        }

        .info-label {
            font-weight: bold;
            color: #666;
        }

        .info-value {
            color: #333;
            font-weight: 500;
        }

        .route-path {
            margin-top: 15px;
            padding: 10px;
            background: #fff;
            border-radius: 5px;
        }

        .route-path-item {
            padding: 8px;
            margin: 5px 0;
            background: #f0f0f0;
            border-radius: 5px;
            border-left: 3px solid #4b6cb7;
        }

        .time-selector {
            padding: 20px;
            background: white;
            border-top: 2px solid #e9ecef;
        }

        .time-selector h3 {
            margin-bottom: 15px;
            color: #333;
        }

        .time-input {
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1.1em;
            width: 200px;
            margin-right: 10px;
        }

        .check-btn {
            padding: 12px 24px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .check-btn:hover {
            background: #218838;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            overflow-y: auto;
        }

        .modal-content {
            background: white;
            margin: 5% auto;
            padding: 30px;
            border-radius: 15px;
            max-width: 600px;
            text-align: center;
            position: relative;
        }

        .close-btn {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 28px;
            font-weight: bold;
            color: #aaa;
            cursor: pointer;
        }

        .close-btn:hover {
            color: #000;
        }

        .station-select {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1.1em;
            margin: 20px 0;
        }

        .result-message {
            font-size: 1.3em;
            font-weight: bold;
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
        }

        .success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .danger {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        #map {
            height: 400px;
            border-radius: 10px;
            margin-top: 20px;
            border: 2px solid #e9ecef;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸš— ä¸Šæµ·é€šå‹¤è·¯çº¿è§„åˆ’</h1>
        </header>

        <div class="info-section">
            <p><strong>å‡ºå‘åœ°ï¼š</strong>ä¸Šæµ·é©¬æˆåŸ</p>
            <p><strong>ç›®çš„åœ°ï¼š</strong>ä¸Šæµ·æ•°æ®äº¤æ˜“æ‰€</p>
            <p><strong>è¦æ±‚åˆ°è¾¾æ—¶é—´ï¼š</strong>09:00å‰</p>
        </div>

        <div class="transport-buttons">
            <button class="transport-btn" onclick="selectTransport('driving')">ğŸš• æ‰“è½¦</button>
            <button class="transport-btn" onclick="selectTransport('transit')">ğŸš‡ åœ°é“</button>
            <button class="transport-btn" onclick="selectTransport('transit')">ğŸšŒ å…¬äº¤è½¦</button>
        </div>

        <div class="routes-container">
            <div class="route-buttons" id="routeButtons"></div>
            <div class="route-details" id="routeDetails"></div>
            <div id="map" class="hidden"></div>
        </div>

        <div class="time-selector">
            <h3>â° æ—¶é—´æ£€æŸ¥</h3>
            <input type="time" class="time-input" id="currentTime" value="08:30">
            <button class="check-btn" onclick="checkTime()">æ£€æŸ¥æ˜¯å¦è¿Ÿåˆ°</button>
        </div>
    </div>

    <div class="modal" id="stationModal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeModal()">&times;</span>
            <h2>ä½ ç°åœ¨åˆ°å“ªå„¿äº†ï¼Ÿ</h2>
            <select class="station-select" id="stationSelect">
                <option value="">è¯·é€‰æ‹©ç«™ç‚¹</option>
            </select>
            <button class="check-btn" onclick="calculateTime()">è®¡ç®—æ—¶é—´</button>
            <div class="result-message hidden" id="resultMessage"></div>
        </div>
    </div>

    <script src="https://webapi.amap.com/maps?v=2.0&key=a8a69c74031c9c30ae768bf1bd5e37ad"></script>
    <script>
        // å…¨å±€å˜é‡
        let currentRoutes = [];
        let selectedRoute = null;
        let allStations = [];
        let map = null;
        let originGeo = null;
        let destGeo = null;
        let amapReady = false;
        const origin = "ä¸Šæµ·é©¬æˆåŸ";
        const destination = "ä¸Šæµ·æ•°æ®äº¤æ˜“æ‰€";
        const targetTime = "09:00";
        const API_KEY = "a8a69c74031c9c30ae768bf1bd5e37ad";

        // ç­‰å¾…é«˜å¾·åœ°å›¾APIåŠ è½½å®Œæˆï¼ˆä»…ç”¨äºåœ°å›¾æ˜¾ç¤ºï¼‰
        function waitForAMap() {
            return new Promise((resolve) => {
                if (typeof AMap !== 'undefined') {
                    amapReady = true;
                    resolve();
                } else {
                    let attempts = 0;
                    const maxAttempts = 50;
                    function checkAMap() {
                        attempts++;
                        if (typeof AMap !== 'undefined') {
                            amapReady = true;
                            resolve();
                        } else if (attempts < maxAttempts) {
                            setTimeout(checkAMap, 100);
                        } else {
                            // å³ä½¿æ²¡åŠ è½½ä¹Ÿç»§ç»­ï¼Œå› ä¸ºåœ°å›¾æ˜¾ç¤ºæ˜¯å¯é€‰çš„
                            resolve();
                        }
                    }
                    checkAMap();
                }
            });
        }

        // åˆå§‹åŒ–åœ°å›¾ï¼ˆä»…ç”¨äºé¡µé¢åŠ è½½æ—¶ï¼Œå®é™…ä½¿ç”¨åœ¨displayRouteOnMapä¸­ï¼‰
        function initMap() {
            return new Promise((resolve) => {
                // åœ°å›¾åœ¨å®é™…éœ€è¦æ˜¾ç¤ºæ—¶æ‰åˆå§‹åŒ–ï¼Œè¿™é‡Œåªåšæ£€æŸ¥
                resolve();
            });
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.onload = function() {
            waitForAMap().then(() => {
                console.log('é«˜å¾·åœ°å›¾APIåŠ è½½å®Œæˆ');
                initMap();
            });
        };

        // é€‰æ‹©äº¤é€šæ–¹å¼
        async function selectTransport(type) {
            console.log('é€‰æ‹©äº¤é€šæ–¹å¼:', type);
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('.transport-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');

            // æ¸…ç©ºä¹‹å‰çš„å†…å®¹
            document.getElementById('routeButtons').innerHTML = '';
            document.getElementById('routeDetails').innerHTML = '';
            document.getElementById('map').classList.add('hidden');
            if (map) {
                map.clearMap();
            }

            // æ˜¾ç¤ºåŠ è½½ä¸­
            document.getElementById('routeButtons').innerHTML = '<div class="loading">æ­£åœ¨æŸ¥è¯¢è·¯çº¿...</div>';

            try {
                console.log('æ­¥éª¤1: æ£€æŸ¥é«˜å¾·åœ°å›¾API');
                // ç¡®ä¿é«˜å¾·åœ°å›¾APIå·²åŠ è½½
                if (!amapReady) {
                    console.log('ç­‰å¾…é«˜å¾·åœ°å›¾APIåŠ è½½...');
                    await Promise.race([
                        waitForAMap(),
                        new Promise((_, reject) => setTimeout(() => reject(new Error('APIåŠ è½½è¶…æ—¶')), 5000))
                    ]);
                }
                
                console.log('æ­¥éª¤2: åˆå§‹åŒ–åœ°å›¾');
                // ç¡®ä¿åœ°å›¾å·²åˆå§‹åŒ–
                await Promise.race([
                    initMap(),
                    new Promise((resolve) => setTimeout(() => resolve(), 2000))
                ]);
                
                // å†æ¬¡ç¡®è®¤AMapå·²åŠ è½½
                if (typeof AMap === 'undefined') {
                    throw new Error('é«˜å¾·åœ°å›¾APIæœªåŠ è½½ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥');
                }

                console.log('æ­¥éª¤3: è·å–èµ·ç‚¹åæ ‡:', origin);
                // è·å–èµ·ç‚¹å’Œç»ˆç‚¹çš„åæ ‡
                originGeo = await Promise.race([
                    getGeocode(origin),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('åœ°ç†ç¼–ç è¶…æ—¶')), 10000))
                ]);
                console.log('èµ·ç‚¹åæ ‡:', originGeo);

                console.log('æ­¥éª¤4: è·å–ç»ˆç‚¹åæ ‡:', destination);
                destGeo = await Promise.race([
                    getGeocode(destination),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('åœ°ç†ç¼–ç è¶…æ—¶')), 10000))
                ]);
                console.log('ç»ˆç‚¹åæ ‡:', destGeo);

                if (!originGeo || !destGeo) {
                    throw new Error('æ— æ³•è·å–åœ°å€åæ ‡ï¼Œè¯·æ£€æŸ¥åœ°å€æ˜¯å¦æ­£ç¡®');
                }

                console.log('æ­¥éª¤5: æŸ¥è¯¢è·¯çº¿, ç±»å‹:', type);
                // æ ¹æ®ç±»å‹è·å–è·¯çº¿
                if (type === 'driving') {
                    await Promise.race([
                        getDrivingRoutes(originGeo, destGeo),
                        new Promise((_, reject) => setTimeout(() => reject(new Error('è·¯çº¿æŸ¥è¯¢è¶…æ—¶')), 15000))
                    ]);
                } else {
                    await Promise.race([
                        getTransitRoutes(originGeo, destGeo),
                        new Promise((_, reject) => setTimeout(() => reject(new Error('è·¯çº¿æŸ¥è¯¢è¶…æ—¶')), 15000))
                    ]);
                }
                console.log('è·¯çº¿æŸ¥è¯¢å®Œæˆ');
            } catch (error) {
                console.error('è·å–è·¯çº¿å¤±è´¥:', error);
                document.getElementById('routeButtons').innerHTML = 
                    `<div class="loading" style="color: red;">è·å–è·¯çº¿å¤±è´¥ï¼š${error.message || 'è¯·ç¨åé‡è¯•'}<br>è¯·æ‰“å¼€æµè§ˆå™¨æ§åˆ¶å°(F12)æŸ¥çœ‹è¯¦ç»†é”™è¯¯ä¿¡æ¯</div>`;
            }
        }

        // åœ°ç†ç¼–ç  - è·å–åæ ‡ï¼ˆä½¿ç”¨WebæœåŠ¡APIï¼‰
        async function getGeocode(address) {
            return new Promise((resolve, reject) => {
                try {
                    const url = `https://restapi.amap.com/v3/geocode/geo?key=${API_KEY}&address=${encodeURIComponent(address)}&city=ä¸Šæµ·å¸‚`;
                    console.log('åœ°ç†ç¼–ç è¯·æ±‚:', url);
                    
                    fetch(url)
                        .then(response => response.json())
                        .then(data => {
                            console.log('åœ°ç†ç¼–ç å“åº”:', data);
                            if (data.status === '1' && data.geocodes && data.geocodes.length > 0) {
                                const location = data.geocodes[0].location.split(',');
                                const result = { lng: parseFloat(location[0]), lat: parseFloat(location[1]) };
                                console.log(`åœ°ç†ç¼–ç æˆåŠŸ: ${address} -> (${result.lng}, ${result.lat})`);
                                resolve(result);
                            } else {
                                console.error('åœ°ç†ç¼–ç å¤±è´¥:', data);
                                reject(new Error(`åœ°ç†ç¼–ç å¤±è´¥: ${data.info || 'æœªçŸ¥é”™è¯¯'}`));
                            }
                        })
                        .catch(error => {
                            console.error('åœ°ç†ç¼–ç è¯·æ±‚å¼‚å¸¸:', error);
                            reject(error);
                        });
                } catch (error) {
                    console.error('åœ°ç†ç¼–ç å¼‚å¸¸:', error);
                    reject(error);
                }
            });
        }

        // è·å–å®æ—¶æ‰“è½¦è´¹ç”¨ï¼ˆä½¿ç”¨é«˜å¾·åœ°å›¾æ‰“è½¦æœåŠ¡APIï¼‰
        async function getRealTimeTaxiCost(origin, destination, distance, duration) {
            try {
                // é«˜å¾·åœ°å›¾æ‰“è½¦æœåŠ¡APIï¼ˆéœ€è¦ç”³è¯·æœåŠ¡ï¼‰
                // å¦‚æœAPIä¸å¯ç”¨ï¼Œä½¿ç”¨æ›´ç²¾ç¡®çš„è´¹ç”¨è®¡ç®—
                const originStr = `${origin.lng},${origin.lat}`;
                const destStr = `${destination.lng},${destination.lat}`;
                
                // å°è¯•è°ƒç”¨é«˜å¾·åœ°å›¾çš„è·¯å¾„è§„åˆ’APIè·å–æ›´è¯¦ç»†çš„ä¿¡æ¯
                // æ³¨æ„ï¼šé«˜å¾·åœ°å›¾çš„è·¯å¾„è§„åˆ’APIå¯èƒ½åŒ…å«tollsï¼ˆè¿‡è·¯è´¹ï¼‰ç­‰ä¿¡æ¯
                // ä½†å®æ—¶æ‰“è½¦è´¹ç”¨éœ€è¦è°ƒç”¨ä¸“é—¨çš„æ‰“è½¦æœåŠ¡API
                
                // ç”±äºé«˜å¾·åœ°å›¾æ²¡æœ‰å…¬å¼€çš„å®æ—¶æ‰“è½¦è´¹ç”¨APIï¼Œæˆ‘ä»¬ä½¿ç”¨æ›´ç²¾ç¡®çš„è®¡ç®—æ–¹å¼
                // ç»“åˆå®æ—¶è·¯å†µå’Œè·ç¦»æ¥è®¡ç®—
                return await calculateRealTimeTaxiCost(distance, duration, origin, destination);
            } catch (error) {
                console.error('è·å–å®æ—¶æ‰“è½¦è´¹ç”¨å¤±è´¥:', error);
                // å¦‚æœå¤±è´¥ï¼Œè¿”å›ä¼°ç®—è´¹ç”¨
                return calculateTaxiCost(distance);
            }
        }

        // è®¡ç®—å®æ—¶æ‰“è½¦è´¹ç”¨ï¼ˆè€ƒè™‘è·¯å†µã€æ—¶é—´ç­‰å› ç´ ï¼‰
        async function calculateRealTimeTaxiCost(distance, duration, origin, destination) {
            const distanceKm = distance / 1000;
            const durationMinutes = duration;
            
            // ä¸Šæµ·å‡ºç§Ÿè½¦è®¡ä»·è§„åˆ™ï¼ˆ2024å¹´ï¼‰ï¼š
            // èµ·æ­¥ä»·ï¼š14å…ƒï¼ˆ3å…¬é‡Œå†…ï¼‰
            // 3-10å…¬é‡Œï¼šæ¯å…¬é‡Œ2.5å…ƒ
            // è¶…è¿‡10å…¬é‡Œï¼šæ¯å…¬é‡Œ3.5å…ƒ
            // å¤œé—´ï¼ˆ23:00-5:00ï¼‰ï¼šåŠ æ”¶30%
            // ä½é€Ÿè¡Œé©¶ï¼ˆæ—¶é€Ÿä½äº12å…¬é‡Œï¼‰ï¼šæ¯5åˆ†é’ŸåŠ æ”¶2.5å…ƒ
            
            let baseCost = 0;
            if (distanceKm <= 3) {
                baseCost = 14;
            } else if (distanceKm <= 10) {
                baseCost = 14 + (distanceKm - 3) * 2.5;
            } else {
                baseCost = 14 + 7 * 2.5 + (distanceKm - 10) * 3.5;
            }
            
            // è€ƒè™‘å®æ—¶è·¯å†µï¼šå¦‚æœå¹³å‡é€Ÿåº¦ä½äº30km/hï¼Œå¯èƒ½æœ‰ä½é€Ÿè¡Œé©¶è´¹
            const avgSpeed = distanceKm / (durationMinutes / 60); // km/h
            let lowSpeedCost = 0;
            if (avgSpeed < 12) {
                // ä½é€Ÿè¡Œé©¶ï¼Œæ¯5åˆ†é’Ÿ2.5å…ƒ
                const lowSpeedMinutes = durationMinutes * (12 - avgSpeed) / 12;
                lowSpeedCost = Math.floor(lowSpeedMinutes / 5) * 2.5;
            }
            
            // è€ƒè™‘æ—¶é—´å› ç´ ï¼šå¤œé—´åŠ æ”¶
            const now = new Date();
            const hour = now.getHours();
            let nightSurcharge = 0;
            if (hour >= 23 || hour < 5) {
                nightSurcharge = baseCost * 0.3;
            }
            
            // è¿‡è·¯è´¹ï¼ˆå¦‚æœæœ‰ï¼‰
            // æ³¨æ„ï¼šé«˜å¾·APIçš„path.tollså­—æ®µå¯èƒ½åŒ…å«è¿‡è·¯è´¹ä¿¡æ¯
            let tolls = 0;
            
            const totalCost = baseCost + lowSpeedCost + nightSurcharge + tolls;
            
            console.log(`å®æ—¶è´¹ç”¨è®¡ç®—: åŸºç¡€=${baseCost}å…ƒ, ä½é€Ÿ=${lowSpeedCost}å…ƒ, å¤œé—´=${nightSurcharge}å…ƒ, è¿‡è·¯è´¹=${tolls}å…ƒ, æ€»è®¡=${totalCost.toFixed(2)}å…ƒ`);
            
            return Math.round(totalCost * 100) / 100;
        }

        // è·å–é©¾è½¦è·¯çº¿ï¼ˆä½¿ç”¨WebæœåŠ¡APIï¼‰
        async function getDrivingRoutes(origin, destination) {
            return new Promise((resolve, reject) => {
                try {
                    console.log('å¼€å§‹æŸ¥è¯¢é©¾è½¦è·¯çº¿:', origin, destination);
                    
                    const originStr = `${origin.lng},${origin.lat}`;
                    const destStr = `${destination.lng},${destination.lat}`;
                    const url = `https://restapi.amap.com/v3/direction/driving?key=${API_KEY}&origin=${originStr}&destination=${destStr}&extensions=all`;
                    
                    console.log('é©¾è½¦è·¯çº¿è¯·æ±‚:', url);
                    
                    fetch(url)
                        .then(response => response.json())
                        .then(async data => {
                            console.log('é©¾è½¦è·¯çº¿å“åº”:', data);
                            if (data.status === '1' && data.route && data.route.paths && data.route.paths.length > 0) {
                                console.log('æ‰¾åˆ°', data.route.paths.length, 'æ¡é©¾è½¦è·¯çº¿');
                                
                                // å¹¶è¡Œè·å–æ‰€æœ‰è·¯çº¿çš„å®æ—¶è´¹ç”¨
                                const routesWithCost = await Promise.all(
                                    data.route.paths.slice(0, 3).map(async (path, index) => {
                                        const distance = parseInt(path.distance);
                                        const duration = Math.round(parseInt(path.duration) / 60);
                                        
                                        // è·å–å®æ—¶æ‰“è½¦è´¹ç”¨
                                        const realTimeCost = await getRealTimeTaxiCost(
                                            origin, 
                                            destination, 
                                            distance, 
                                            duration
                                        );
                                        
                                        // ä»pathä¸­æå–è¿‡è·¯è´¹ï¼ˆå¦‚æœæœ‰ï¼‰
                                        const tolls = parseFloat(path.tolls || 0);
                                        
                                        return {
                                            id: index + 1,
                                            type: 'driving',
                                            distance: distance,
                                            duration: duration,
                                            cost: realTimeCost + tolls, // å®æ—¶è´¹ç”¨ + è¿‡è·¯è´¹
                                            tolls: tolls, // è¿‡è·¯è´¹
                                            steps: path.steps || [],
                                            path: path,
                                            route: path
                                        };
                                    })
                                );
                                
                                currentRoutes = routesWithCost;
                                console.log('å¤„ç†åçš„è·¯çº¿ï¼ˆå«å®æ—¶è´¹ç”¨ï¼‰:', currentRoutes);
                                displayRoutes();
                                // ä¸è‡ªåŠ¨æ˜¾ç¤ºåœ°å›¾ï¼Œç­‰ç”¨æˆ·é€‰æ‹©è·¯çº¿åå†æ˜¾ç¤º
                                resolve();
                            } else {
                                console.error('é©¾è½¦è·¯çº¿æŸ¥è¯¢å¤±è´¥:', data);
                                reject(new Error(`æœªæ‰¾åˆ°é©¾è½¦è·¯çº¿: ${data.info || 'æœªçŸ¥é”™è¯¯'}`));
                            }
                        })
                        .catch(error => {
                            console.error('é©¾è½¦è·¯çº¿è¯·æ±‚å¼‚å¸¸:', error);
                            reject(error);
                        });
                } catch (error) {
                    console.error('é©¾è½¦è·¯çº¿æŸ¥è¯¢å¼‚å¸¸:', error);
                    reject(error);
                }
            });
        }

        // è·å–å…¬äº¤è·¯çº¿ï¼ˆä½¿ç”¨WebæœåŠ¡APIï¼‰
        async function getTransitRoutes(origin, destination) {
            return new Promise((resolve, reject) => {
                try {
                    console.log('å¼€å§‹æŸ¥è¯¢å…¬äº¤è·¯çº¿:', origin, destination);
                    
                    const originStr = `${origin.lng},${origin.lat}`;
                    const destStr = `${destination.lng},${destination.lat}`;
                    const url = `https://restapi.amap.com/v3/direction/transit/integrated?key=${API_KEY}&origin=${originStr}&destination=${destStr}&city=ä¸Šæµ·&cityd=ä¸Šæµ·&extensions=all`;
                    
                    console.log('å…¬äº¤è·¯çº¿è¯·æ±‚:', url);
                    
                    fetch(url)
                        .then(response => response.json())
                        .then(data => {
                            console.log('å…¬äº¤è·¯çº¿å“åº”:', data);
                            if (data.status === '1' && data.route && data.route.transits && data.route.transits.length > 0) {
                                console.log('æ‰¾åˆ°', data.route.transits.length, 'æ¡å…¬äº¤è·¯çº¿');
                                currentRoutes = data.route.transits.slice(0, 3).map((transit, index) => {
                                    console.log(`è·¯çº¿${index + 1}çš„åŸå§‹æ•°æ®:`, transit);
                                    const segments = transit.segments || [];
                                    const stations = [];
                                    const transferDetails = []; // æ¯æ¬¡æ¢ä¹˜çš„è¯¦ç»†ä¿¡æ¯
                                    let totalCost = 0;
                                    
                                    segments.forEach((segment, segIndex) => {
                                        if (segment.walking) {
                                            // æ­¥è¡Œæ®µï¼Œä¸è®°å½•åˆ°stationsï¼Œä½†è®°å½•åˆ°transferDetails
                                            transferDetails.push({
                                                type: 'walking',
                                                duration: Math.round(parseInt(segment.walking.duration || 0) / 60),
                                                distance: parseInt(segment.walking.distance || 0),
                                                cost: 0,
                                                description: `æ­¥è¡Œ ${Math.round(parseInt(segment.walking.distance || 0))}ç±³`
                                            });
                                        } else if (segment.bus && segment.bus.buslines) {
                                            // æ¯ä¸ªbus segmentå¯èƒ½åŒ…å«å¤šæ¡å…¬äº¤çº¿è·¯ï¼Œä½†é€šå¸¸åªæœ‰ä¸€æ¡
                                            segment.bus.buslines.forEach(busline => {
                                                const busDuration = Math.round(parseInt(busline.duration || 0) / 60);
                                                const busDistance = parseInt(busline.distance || 0);
                                                
                                                if (busline.departure_stop && busline.arrival_stop) {
                                                    // é¿å…é‡å¤æ·»åŠ ç›¸åŒçš„ç«™ç‚¹
                                                    const stationKey = `${busline.name}_${busline.departure_stop.name}_${busline.arrival_stop.name}`;
                                                    if (!stations.find(s => s.key === stationKey)) {
                                                        stations.push({
                                                            key: stationKey,
                                                            type: 'bus',
                                                            line: busline.name,
                                                            from: busline.departure_stop.name,
                                                            to: busline.arrival_stop.name,
                                                            duration: busDuration,
                                                            distance: busDistance,
                                                            cost: 2
                                                        });
                                                    }
                                                    
                                                    transferDetails.push({
                                                        type: 'bus',
                                                        line: busline.name,
                                                        from: busline.departure_stop.name,
                                                        to: busline.arrival_stop.name,
                                                        duration: busDuration,
                                                        distance: busDistance,
                                                        cost: 2,
                                                        description: `ğŸšŒ ${busline.name}: ${busline.departure_stop.name} â†’ ${busline.arrival_stop.name}`
                                                    });
                                                }
                                            });
                                            // æ¯ä¸ªbus segmentåªè®¡ç®—ä¸€æ¬¡è´¹ç”¨ï¼ˆ2å…ƒï¼‰
                                            totalCost += 2;
                                        } else if (segment.railway && segment.railway.space) {
                                            segment.railway.space.forEach(space => {
                                                if (space.segments) {
                                                    space.segments.forEach(seg => {
                                                        const railDuration = Math.round(parseInt(seg.duration || 0) / 60);
                                                        const railDistance = parseInt(seg.distance || 0);
                                                        
                                                        if (seg.entrance && seg.exit) {
                                                            const stationKey = `${seg.name || 'åœ°é“'}_${seg.entrance.name}_${seg.exit.name}`;
                                                            if (!stations.find(s => s.key === stationKey)) {
                                                                stations.push({
                                                                    key: stationKey,
                                                                    type: 'subway',
                                                                    line: seg.name || 'åœ°é“',
                                                                    from: seg.entrance.name,
                                                                    to: seg.exit.name,
                                                                    duration: railDuration,
                                                                    distance: railDistance,
                                                                    cost: 3
                                                                });
                                                            }
                                                            
                                                            transferDetails.push({
                                                                type: 'subway',
                                                                line: seg.name || 'åœ°é“',
                                                                from: seg.entrance.name,
                                                                to: seg.exit.name,
                                                                duration: railDuration,
                                                                distance: railDistance,
                                                                cost: 3,
                                                                description: `ğŸš‡ ${seg.name || 'åœ°é“'}: ${seg.entrance.name} â†’ ${seg.exit.name}`
                                                            });
                                                        }
                                                    });
                                                }
                                            });
                                            // æ¯ä¸ªrailway segmentåªè®¡ç®—ä¸€æ¬¡è´¹ç”¨ï¼ˆ3å…ƒï¼‰
                                            totalCost += 3;
                                        }
                                    });

                                    // ä»transit.costè·å–æ€»æ—¶é—´å’Œæ€»è·ç¦»
                                    // é«˜å¾·APIè¿”å›çš„æ•°æ®ç»“æ„ï¼štransit.cost.distance å’Œ transit.cost.duration
                                    let totalDistance = 0;
                                    let totalDuration = 0;
                                    
                                    console.log(`è·¯çº¿${index + 1}çš„costå­—æ®µ:`, transit.cost);
                                    
                                    if (transit.cost) {
                                        // é«˜å¾·APIè¿”å›çš„durationå•ä½æ˜¯ç§’ï¼Œdistanceå•ä½æ˜¯ç±³
                                        totalDistance = parseInt(transit.cost.distance || 0);
                                        totalDuration = Math.round(parseInt(transit.cost.duration || 0) / 60);
                                        console.log(`ä»costè·å–: è·ç¦»=${totalDistance}ç±³, æ—¶é—´=${totalDuration}åˆ†é’Ÿ`);
                                    }
                                    
                                    // å¦‚æœcostä¸­æ²¡æœ‰æ•°æ®ï¼Œå°è¯•ä»å…¶ä»–å­—æ®µè·å–
                                    if (totalDistance === 0 || totalDuration === 0) {
                                        if (transit.distance) {
                                            totalDistance = parseInt(transit.distance);
                                        }
                                        if (transit.duration) {
                                            totalDuration = Math.round(parseInt(transit.duration) / 60);
                                        }
                                        console.log(`ä»transitç›´æ¥è·å–: è·ç¦»=${totalDistance}ç±³, æ—¶é—´=${totalDuration}åˆ†é’Ÿ`);
                                    }
                                    
                                    // å¦‚æœè¿˜æ˜¯0ï¼Œå°è¯•ä»segmentsç´¯åŠ 
                                    if (totalDistance === 0 || totalDuration === 0) {
                                        let segDistance = 0;
                                        let segDuration = 0;
                                        segments.forEach(seg => {
                                            if (seg.walking) {
                                                segDistance += parseInt(seg.walking.distance || 0);
                                                segDuration += parseInt(seg.walking.duration || 0);
                                            } else if (seg.bus && seg.bus.buslines) {
                                                seg.bus.buslines.forEach(busline => {
                                                    segDistance += parseInt(busline.distance || 0);
                                                    segDuration += parseInt(busline.duration || 0);
                                                });
                                            } else if (seg.railway && seg.railway.space) {
                                                seg.railway.space.forEach(space => {
                                                    if (space.segments) {
                                                        space.segments.forEach(s => {
                                                            segDistance += parseInt(s.distance || 0);
                                                            segDuration += parseInt(s.duration || 0);
                                                        });
                                                    }
                                                });
                                            }
                                        });
                                        if (segDistance > 0) totalDistance = segDistance;
                                        if (segDuration > 0) totalDuration = Math.round(segDuration / 60);
                                        console.log(`ä»segmentsç´¯åŠ : è·ç¦»=${totalDistance}ç±³, æ—¶é—´=${totalDuration}åˆ†é’Ÿ`);
                                    }
                                    
                                    // è´¹ç”¨è®¡ç®—ï¼šä»APIè·å–æˆ–æŒ‰æ¢ä¹˜æ¬¡æ•°è®¡ç®—
                                    if (transit.cost && transit.cost.ticket_price) {
                                        totalCost = parseFloat(transit.cost.ticket_price) || totalCost;
                                        console.log(`ä»costè·å–è´¹ç”¨: ${totalCost}å…ƒ`);
                                    } else {
                                        // å¦‚æœæ²¡æœ‰è´¹ç”¨ä¿¡æ¯ï¼ŒæŒ‰æ¢ä¹˜æ¬¡æ•°è®¡ç®—
                                        // æ¯æ¡å…¬äº¤/åœ°é“çº¿è·¯çš„è´¹ç”¨
                                        console.log(`æŒ‰æ¢ä¹˜æ¬¡æ•°è®¡ç®—è´¹ç”¨: ${totalCost}å…ƒ`);
                                    }

                                    return {
                                        id: index + 1,
                                        type: 'transit',
                                        distance: totalDistance,
                                        duration: totalDuration,
                                        cost: totalCost,
                                        segments: segments,
                                        stations: stations,
                                        transferDetails: transferDetails, // æ¯æ¬¡æ¢ä¹˜çš„è¯¦ç»†ä¿¡æ¯
                                        plan: transit
                                    };
                                });
                                console.log('å¤„ç†åçš„è·¯çº¿:', currentRoutes);
                                // ä¿å­˜åŸå§‹APIæ•°æ®ä»¥ä¾¿æå–ç«™ç‚¹
                                currentRoutes.forEach((route, index) => {
                                    route.rawTransitData = data.route.transits[index];
                                });
                                displayRoutes();
                                collectAllStations();
                                // ä¸è‡ªåŠ¨æ˜¾ç¤ºåœ°å›¾ï¼Œç­‰ç”¨æˆ·é€‰æ‹©è·¯çº¿åå†æ˜¾ç¤º
                                resolve();
                            } else {
                                console.error('å…¬äº¤è·¯çº¿æŸ¥è¯¢å¤±è´¥:', data);
                                reject(new Error(`æœªæ‰¾åˆ°å…¬äº¤è·¯çº¿: ${data.info || 'æœªçŸ¥é”™è¯¯'}`));
                            }
                        })
                        .catch(error => {
                            console.error('å…¬äº¤è·¯çº¿è¯·æ±‚å¼‚å¸¸:', error);
                            reject(error);
                        });
                } catch (error) {
                    console.error('å…¬äº¤è·¯çº¿æŸ¥è¯¢å¼‚å¸¸:', error);
                    reject(error);
                }
            });
        }

        // è®¡ç®—æ‰“è½¦è´¹ç”¨ï¼ˆä¸Šæµ·å‡ºç§Ÿè½¦è®¡ä»·è§„åˆ™ï¼‰
        function calculateTaxiCost(distance) {
            const distanceKm = distance / 1000;
            // ä¸Šæµ·å‡ºç§Ÿè½¦ï¼šèµ·æ­¥ä»·14å…ƒï¼ˆ3å…¬é‡Œå†…ï¼‰ï¼Œè¶…è¿‡3å…¬é‡Œæ¯å…¬é‡Œ2.5å…ƒï¼Œè¶…è¿‡10å…¬é‡Œæ¯å…¬é‡Œ3.5å…ƒ
            if (distanceKm <= 3) {
                return 14;
            } else if (distanceKm <= 10) {
                return Math.round((14 + (distanceKm - 3) * 2.5) * 100) / 100;
            } else {
                return Math.round((14 + 7 * 2.5 + (distanceKm - 10) * 3.5) * 100) / 100;
            }
        }

        // æ˜¾ç¤ºè·¯çº¿æŒ‰é’®
        function displayRoutes() {
            console.log('æ˜¾ç¤ºè·¯çº¿æŒ‰é’®, è·¯çº¿æ•°é‡:', currentRoutes.length);
            const container = document.getElementById('routeButtons');
            if (!container) {
                console.error('æ‰¾ä¸åˆ°routeButtonså®¹å™¨');
                return;
            }
            container.innerHTML = '';
            
            if (currentRoutes.length === 0) {
                container.innerHTML = '<div class="loading" style="color: red;">æœªæ‰¾åˆ°è·¯çº¿</div>';
                return;
            }
            
            currentRoutes.forEach(route => {
                const btn = document.createElement('button');
                btn.className = 'route-btn';
                btn.innerHTML = `
                    <strong>è·¯çº¿ ${route.id}</strong><br>
                    æ—¶é—´: ${route.duration}åˆ†é’Ÿ | è´¹ç”¨: ${route.cost}å…ƒ
                `;
                btn.onclick = () => selectRoute(route);
                container.appendChild(btn);
            });
            console.log('è·¯çº¿æŒ‰é’®å·²åˆ›å»º');
        }

        // åœ¨åœ°å›¾ä¸Šæ˜¾ç¤ºè·¯çº¿
        async function displayRouteOnMap(origin, destination, routeType, selectedRouteId = null) {
            try {
                if (!amapReady || typeof AMap === 'undefined') {
                    console.log('åœ°å›¾APIæœªåŠ è½½ï¼Œè·³è¿‡åœ°å›¾æ˜¾ç¤º');
                    return;
                }
                
                // å…ˆæ˜¾ç¤ºåœ°å›¾å®¹å™¨
                const mapDiv = document.getElementById('map');
                if (!mapDiv) {
                    console.error('æ‰¾ä¸åˆ°åœ°å›¾å®¹å™¨');
                    return;
                }
                mapDiv.classList.remove('hidden');
                
                // ç­‰å¾…å®¹å™¨æ˜¾ç¤ºåå†åˆå§‹åŒ–åœ°å›¾
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // åˆå§‹åŒ–æˆ–é‡æ–°åˆ›å»ºåœ°å›¾
                if (map) {
                    map.destroy();
                    map = null;
                }
                
                // ç¡®ä¿åæ ‡æœ‰æ•ˆ
                if (isNaN(origin.lng) || isNaN(origin.lat) || isNaN(destination.lng) || isNaN(destination.lat)) {
                    console.error('åæ ‡æ— æ•ˆ:', origin, destination);
                    return;
                }
                
                map = new AMap.Map('map', {
                    zoom: 13,
                    center: [origin.lng, origin.lat],
                    viewMode: '2D' // ä½¿ç”¨2Dæ¨¡å¼æ›´ç¨³å®š
                });
                
                // ç­‰å¾…åœ°å›¾åŠ è½½å®Œæˆ
                await new Promise((resolve) => {
                    map.on('complete', resolve);
                    setTimeout(resolve, 1000); // è¶…æ—¶ä¿æŠ¤
                });
                
                // æ·»åŠ èµ·ç‚¹å’Œç»ˆç‚¹æ ‡è®°
                const originMarker = new AMap.Marker({
                    position: new AMap.LngLat(origin.lng, origin.lat),
                    title: 'èµ·ç‚¹ï¼š' + origin
                });
                const destMarker = new AMap.Marker({
                    position: new AMap.LngLat(destination.lng, destination.lat),
                    title: 'ç»ˆç‚¹ï¼š' + destination
                });
                map.add([originMarker, destMarker]);
                
                // ç¡®å®šè¦æ˜¾ç¤ºçš„è·¯çº¿ï¼ˆå¦‚æœæŒ‡å®šäº†IDåˆ™æ˜¾ç¤ºè¯¥è·¯çº¿ï¼Œå¦åˆ™æ˜¾ç¤ºç¬¬ä¸€æ¡ï¼‰
                let routeToShow = null;
                if (selectedRouteId !== null) {
                    routeToShow = currentRoutes.find(r => r.id === selectedRouteId);
                }
                if (!routeToShow && currentRoutes.length > 0) {
                    routeToShow = currentRoutes[0];
                }
                
                if (!routeToShow) {
                    map.setFitView([originMarker, destMarker]);
                    return;
                }
                
                console.log('æ˜¾ç¤ºè·¯çº¿:', routeToShow);
                    
                // æ ¹æ®è·¯çº¿ç±»å‹æ˜¾ç¤ºè·¯çº¿
                if (routeType === 'driving') {
                    // æ˜¾ç¤ºé©¾è½¦è·¯çº¿
                    const path = [];
                    if (routeToShow.path && routeToShow.path.steps) {
                        console.log('é©¾è½¦è·¯çº¿stepsæ•°é‡:', routeToShow.path.steps.length);
                        routeToShow.path.steps.forEach((step, stepIndex) => {
                            if (step.polyline) {
                                const coords = step.polyline.split(';');
                                coords.forEach(coord => {
                                    if (coord && coord.trim()) {
                                        const [lng, lat] = coord.split(',');
                                        const lngNum = parseFloat(lng);
                                        const latNum = parseFloat(lat);
                                        if (!isNaN(lngNum) && !isNaN(latNum)) {
                                            path.push(new AMap.LngLat(lngNum, latNum));
                                        }
                                    }
                                });
                            }
                        });
                    }
                    console.log('æå–çš„è·¯å¾„ç‚¹æ•°:', path.length);
                    if (path.length > 0) {
                        const polyline = new AMap.Polyline({
                            path: path,
                            strokeColor: '#3366FF',
                            strokeWeight: 5,
                            strokeOpacity: 0.8
                        });
                        map.add(polyline);
                        map.setFitView([originMarker, destMarker, polyline]);
                        console.log('é©¾è½¦è·¯çº¿å·²ç»˜åˆ¶åˆ°åœ°å›¾');
                    } else {
                        console.warn('æœªæ‰¾åˆ°é©¾è½¦è·¯çº¿è·¯å¾„æ•°æ®');
                        map.setFitView([originMarker, destMarker]);
                    }
                } else if (routeType === 'transit') {
                    // æ˜¾ç¤ºå…¬äº¤è·¯çº¿
                    const allPaths = [];
                    if (routeToShow.plan && routeToShow.plan.segments) {
                        console.log('å…¬äº¤è·¯çº¿segmentsæ•°é‡:', routeToShow.plan.segments.length);
                        routeToShow.plan.segments.forEach((segment, segIndex) => {
                            if (segment.walking && segment.walking.path) {
                                const path = [];
                                const coords = segment.walking.path.split(';');
                                coords.forEach(coord => {
                                    if (coord && coord.trim()) {
                                        const [lng, lat] = coord.split(',');
                                        const lngNum = parseFloat(lng);
                                        const latNum = parseFloat(lat);
                                        if (!isNaN(lngNum) && !isNaN(latNum)) {
                                            path.push(new AMap.LngLat(lngNum, latNum));
                                        }
                                    }
                                });
                                if (path.length > 0) {
                                    allPaths.push({path: path, color: '#999999'}); // ç°è‰²è¡¨ç¤ºæ­¥è¡Œ
                                }
                            } else if (segment.bus && segment.bus.buslines) {
                                segment.bus.buslines.forEach(busline => {
                                    if (busline.polyline) {
                                        const path = [];
                                        const coords = busline.polyline.split(';');
                                        coords.forEach(coord => {
                                            if (coord && coord.trim()) {
                                                const [lng, lat] = coord.split(',');
                                                const lngNum = parseFloat(lng);
                                                const latNum = parseFloat(lat);
                                                if (!isNaN(lngNum) && !isNaN(latNum)) {
                                                    path.push(new AMap.LngLat(lngNum, latNum));
                                                }
                                            }
                                        });
                                        if (path.length > 0) {
                                            allPaths.push({path: path, color: '#FF6600'}); // æ©™è‰²è¡¨ç¤ºå…¬äº¤
                                        }
                                    }
                                });
                            } else if (segment.railway && segment.railway.space) {
                                segment.railway.space.forEach(space => {
                                    if (space.segments) {
                                        space.segments.forEach(seg => {
                                            if (seg.polyline) {
                                                const path = [];
                                                const coords = seg.polyline.split(';');
                                                coords.forEach(coord => {
                                                    if (coord && coord.trim()) {
                                                        const [lng, lat] = coord.split(',');
                                                        const lngNum = parseFloat(lng);
                                                        const latNum = parseFloat(lat);
                                                        if (!isNaN(lngNum) && !isNaN(latNum)) {
                                                            path.push(new AMap.LngLat(lngNum, latNum));
                                                        }
                                                    }
                                                });
                                                if (path.length > 0) {
                                                    allPaths.push({path: path, color: '#00AAFF'}); // è“è‰²è¡¨ç¤ºåœ°é“
                                                }
                                            }
                                        });
                                    }
                                });
                            }
                        });
                    }
                    console.log('æå–çš„è·¯å¾„æ®µæ•°:', allPaths.length);
                    if (allPaths.length > 0) {
                        const polylines = [];
                        allPaths.forEach(pathData => {
                            const polyline = new AMap.Polyline({
                                path: pathData.path,
                                strokeColor: pathData.color,
                                strokeWeight: 5,
                                strokeOpacity: 0.8
                            });
                            map.add(polyline);
                            polylines.push(polyline);
                        });
                        map.setFitView([originMarker, destMarker, ...polylines]);
                        console.log('å…¬äº¤è·¯çº¿å·²ç»˜åˆ¶åˆ°åœ°å›¾');
                    } else {
                        console.warn('æœªæ‰¾åˆ°å…¬äº¤è·¯çº¿è·¯å¾„æ•°æ®');
                        map.setFitView([originMarker, destMarker]);
                    }
                } else {
                    map.setFitView([originMarker, destMarker]);
                }
            } catch (error) {
                console.error('æ˜¾ç¤ºåœ°å›¾å¤±è´¥:', error);
                // å³ä½¿åœ°å›¾æ˜¾ç¤ºå¤±è´¥ï¼Œä¹Ÿä¸å½±å“å…¶ä»–åŠŸèƒ½
            }
        }

        // é€‰æ‹©è·¯çº¿
        function selectRoute(route) {
            selectedRoute = route;
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('.route-btn').forEach(btn => btn.classList.remove('selected'));
            event.target.classList.add('selected');

            // æ˜¾ç¤ºè·¯çº¿è¯¦æƒ…
            displayRouteDetails(route);
            
            // åœ¨åœ°å›¾ä¸Šæ˜¾ç¤ºé€‰ä¸­çš„è·¯çº¿
            if (originGeo && destGeo) {
                displayRouteOnMap(originGeo, destGeo, route.type, route.id);
            }
        }

        // æ˜¾ç¤ºè·¯çº¿è¯¦æƒ…
        function displayRouteDetails(route) {
            const container = document.getElementById('routeDetails');
            let html = `
                <div class="route-info">
                    <h3>è·¯çº¿è¯¦æƒ…</h3>
                    <div class="info-item">
                        <span class="info-label">æ€»æ—¶é—´ï¼š</span>
                        <span class="info-value">${route.duration} åˆ†é’Ÿ</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">æ€»è·ç¦»ï¼š</span>
                        <span class="info-value">${(route.distance / 1000).toFixed(2)} å…¬é‡Œ</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">æ€»è´¹ç”¨ï¼š</span>
                        <span class="info-value">${typeof route.cost === 'number' ? route.cost.toFixed(2) : route.cost} å…ƒ</span>
                    </div>
                    ${route.tolls && route.tolls > 0 ? `
                    <div class="info-item">
                        <span class="info-label">è¿‡è·¯è´¹ï¼š</span>
                        <span class="info-value">${route.tolls.toFixed(2)} å…ƒ</span>
                    </div>
                    ` : ''}
                </div>
            `;

            if (route.type === 'driving') {
                html += '<div class="route-path"><h4>è¡Œé©¶è·¯å¾„ï¼š</h4>';
                if (route.steps && route.steps.length > 0) {
                    route.steps.forEach((step, index) => {
                        const instruction = step.instruction || step.road || 'é“è·¯';
                        html += `<div class="route-path-item">${index + 1}. ${instruction}</div>`;
                    });
                }
                html += '</div>';
            } else if (route.type === 'transit') {
                html += '<div class="route-path"><h4>æ¢ä¹˜ä¿¡æ¯ï¼š</h4>';
                if (route.transferDetails && route.transferDetails.length > 0) {
                    // ä½¿ç”¨è¯¦ç»†çš„æ¢ä¹˜ä¿¡æ¯
                    route.transferDetails.forEach((transfer, index) => {
                        if (transfer.type === 'walking') {
                            html += `<div class="route-path-item">
                                ${index + 1}. ğŸš¶ ${transfer.description} (${transfer.duration}åˆ†é’Ÿ)
                            </div>`;
                        } else {
                            html += `<div class="route-path-item">
                                ${index + 1}. ${transfer.description}<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;æ—¶é—´: ${transfer.duration}åˆ†é’Ÿ | è·ç¦»: ${(transfer.distance / 1000).toFixed(2)}å…¬é‡Œ | è´¹ç”¨: ${transfer.cost}å…ƒ
                            </div>`;
                        }
                    });
                } else if (route.stations && route.stations.length > 0) {
                    // å¦‚æœæ²¡æœ‰transferDetailsï¼Œä½¿ç”¨stations
                    route.stations.forEach((station, index) => {
                        const duration = station.duration ? ` (${station.duration}åˆ†é’Ÿ)` : '';
                        const cost = station.cost ? ` | è´¹ç”¨: ${station.cost}å…ƒ` : '';
                        html += `<div class="route-path-item">
                            ${index + 1}. ${station.type === 'subway' ? 'ğŸš‡' : 'ğŸšŒ'} 
                            ${station.line}: ${station.from} â†’ ${station.to}${duration}${cost}
                        </div>`;
                    });
                } else if (route.segments && route.segments.length > 0) {
                    // å¦‚æœæ²¡æœ‰è§£æåˆ°ç«™ç‚¹ï¼Œå°è¯•ä»segmentsä¸­æå–
                    route.segments.forEach((segment, index) => {
                        if (segment.bus && segment.bus.buslines) {
                            segment.bus.buslines.forEach(busline => {
                                html += `<div class="route-path-item">
                                    ${index + 1}. ğŸšŒ ${busline.name}: ${busline.departure_stop?.name || ''} â†’ ${busline.arrival_stop?.name || ''}
                                </div>`;
                            });
                        } else if (segment.railway && segment.railway.lines) {
                            segment.railway.lines.forEach(line => {
                                html += `<div class="route-path-item">
                                    ${index + 1}. ğŸš‡ ${line.name || 'åœ°é“'}: ${line.departure_stop?.name || ''} â†’ ${line.arrival_stop?.name || ''}
                                </div>`;
                            });
                        }
                    });
                }
                html += '</div>';
            }

            container.innerHTML = html;
        }

        // æ”¶é›†æ‰€æœ‰ç«™ç‚¹ï¼ˆåŒ…æ‹¬æ‰€æœ‰ä¸­é—´ç«™ç‚¹ï¼‰
        function collectAllStations() {
            allStations = [];
            const stationMap = new Map(); // ä½¿ç”¨Mapæ¥å»é‡ï¼Œkeyä¸º"line_name"
            
            currentRoutes.forEach(route => {
                // ä¼˜å…ˆä»åŸå§‹APIæ•°æ®ä¸­æå–
                const rawData = route.rawTransitData || route.plan;
                
                if (rawData && rawData.segments) {
                    rawData.segments.forEach(segment => {
                        // å¤„ç†å…¬äº¤çº¿è·¯
                        if (segment.bus && segment.bus.buslines) {
                            segment.bus.buslines.forEach(busline => {
                                const lineName = busline.name;
                                
                                // æ·»åŠ èµ·ç‚¹ç«™
                                if (busline.departure_stop && busline.departure_stop.name) {
                                    const key = `${lineName}_${busline.departure_stop.name}`;
                                    if (!stationMap.has(key)) {
                                        stationMap.set(key, {
                                            name: busline.departure_stop.name,
                                            line: lineName,
                                            type: 'bus'
                                        });
                                    }
                                }
                                
                                // æ·»åŠ æ‰€æœ‰é€”ç»ç«™ç‚¹ï¼ˆvia_stopsï¼‰
                                if (busline.via_stops && Array.isArray(busline.via_stops)) {
                                    busline.via_stops.forEach(viaStop => {
                                        if (viaStop && viaStop.name) {
                                            const key = `${lineName}_${viaStop.name}`;
                                            if (!stationMap.has(key)) {
                                                stationMap.set(key, {
                                                    name: viaStop.name,
                                                    line: lineName,
                                                    type: 'bus'
                                                });
                                            }
                                        }
                                    });
                                }
                                
                                // æ·»åŠ ç»ˆç‚¹ç«™
                                if (busline.arrival_stop && busline.arrival_stop.name) {
                                    const key = `${lineName}_${busline.arrival_stop.name}`;
                                    if (!stationMap.has(key)) {
                                        stationMap.set(key, {
                                            name: busline.arrival_stop.name,
                                            line: lineName,
                                            type: 'bus'
                                        });
                                    }
                                }
                            });
                        }
                        
                        // å¤„ç†åœ°é“çº¿è·¯
                        if (segment.railway && segment.railway.space) {
                            segment.railway.space.forEach(space => {
                                if (space.segments && Array.isArray(space.segments)) {
                                    space.segments.forEach(seg => {
                                        const lineName = seg.name || 'åœ°é“';
                                        
                                        // æ·»åŠ èµ·ç‚¹ç«™
                                        if (seg.entrance && seg.entrance.name) {
                                            const key = `${lineName}_${seg.entrance.name}`;
                                            if (!stationMap.has(key)) {
                                                stationMap.set(key, {
                                                    name: seg.entrance.name,
                                                    line: lineName,
                                                    type: 'subway'
                                                });
                                            }
                                        }
                                        
                                        // æ·»åŠ æ‰€æœ‰é€”ç»ç«™ç‚¹ï¼ˆvia_stopsï¼‰
                                        if (seg.via_stops && Array.isArray(seg.via_stops)) {
                                            seg.via_stops.forEach(viaStop => {
                                                if (viaStop && viaStop.name) {
                                                    const key = `${lineName}_${viaStop.name}`;
                                                    if (!stationMap.has(key)) {
                                                        stationMap.set(key, {
                                                            name: viaStop.name,
                                                            line: lineName,
                                                            type: 'subway'
                                                        });
                                                    }
                                                }
                                            });
                                        }
                                        
                                        // æ·»åŠ ç»ˆç‚¹ç«™
                                        if (seg.exit && seg.exit.name) {
                                            const key = `${lineName}_${seg.exit.name}`;
                                            if (!stationMap.has(key)) {
                                                stationMap.set(key, {
                                                    name: seg.exit.name,
                                                    line: lineName,
                                                    type: 'subway'
                                                });
                                            }
                                        }
                                    });
                                }
                            });
                        }
                    });
                }
                
                // å¦‚æœåŸå§‹æ•°æ®ä¸å­˜åœ¨ï¼Œä»segmentsä¸­æå–
                if (route.segments && route.segments.length > 0) {
                    route.segments.forEach(segment => {
                        if (segment.bus && segment.bus.buslines) {
                            segment.bus.buslines.forEach(busline => {
                                const lineName = busline.name;
                                
                                // æ·»åŠ èµ·ç‚¹ç«™
                                if (busline.departure_stop && busline.departure_stop.name) {
                                    const key = `${lineName}_${busline.departure_stop.name}`;
                                    if (!stationMap.has(key)) {
                                        stationMap.set(key, {
                                            name: busline.departure_stop.name,
                                            line: lineName,
                                            type: 'bus'
                                        });
                                    }
                                }
                                
                                // æ·»åŠ æ‰€æœ‰é€”ç»ç«™ç‚¹
                                if (busline.via_stops && Array.isArray(busline.via_stops)) {
                                    busline.via_stops.forEach(viaStop => {
                                        if (viaStop && viaStop.name) {
                                            const key = `${lineName}_${viaStop.name}`;
                                            if (!stationMap.has(key)) {
                                                stationMap.set(key, {
                                                    name: viaStop.name,
                                                    line: lineName,
                                                    type: 'bus'
                                                });
                                            }
                                        }
                                    });
                                }
                                
                                // æ·»åŠ ç»ˆç‚¹ç«™
                                if (busline.arrival_stop && busline.arrival_stop.name) {
                                    const key = `${lineName}_${busline.arrival_stop.name}`;
                                    if (!stationMap.has(key)) {
                                        stationMap.set(key, {
                                            name: busline.arrival_stop.name,
                                            line: lineName,
                                            type: 'bus'
                                        });
                                    }
                                }
                            });
                        } else if (segment.railway && segment.railway.space) {
                            segment.railway.space.forEach(space => {
                                if (space.segments && Array.isArray(space.segments)) {
                                    space.segments.forEach(seg => {
                                        const lineName = seg.name || 'åœ°é“';
                                        
                                        // æ·»åŠ èµ·ç‚¹ç«™
                                        if (seg.entrance && seg.entrance.name) {
                                            const key = `${lineName}_${seg.entrance.name}`;
                                            if (!stationMap.has(key)) {
                                                stationMap.set(key, {
                                                    name: seg.entrance.name,
                                                    line: lineName,
                                                    type: 'subway'
                                                });
                                            }
                                        }
                                        
                                        // æ·»åŠ æ‰€æœ‰é€”ç»ç«™ç‚¹
                                        if (seg.via_stops && Array.isArray(seg.via_stops)) {
                                            seg.via_stops.forEach(viaStop => {
                                                if (viaStop && viaStop.name) {
                                                    const key = `${lineName}_${viaStop.name}`;
                                                    if (!stationMap.has(key)) {
                                                        stationMap.set(key, {
                                                            name: viaStop.name,
                                                            line: lineName,
                                                            type: 'subway'
                                                        });
                                                    }
                                                }
                                            });
                                        }
                                        
                                        // æ·»åŠ ç»ˆç‚¹ç«™
                                        if (seg.exit && seg.exit.name) {
                                            const key = `${lineName}_${seg.exit.name}`;
                                            if (!stationMap.has(key)) {
                                                stationMap.set(key, {
                                                    name: seg.exit.name,
                                                    line: lineName,
                                                    type: 'subway'
                                                });
                                            }
                                        }
                                    });
                                }
                            });
                        }
                    });
                }
            });
            
            // å°†Mapè½¬æ¢ä¸ºæ•°ç»„
            allStations = Array.from(stationMap.values());
            console.log('æ”¶é›†åˆ°çš„æ‰€æœ‰ç«™ç‚¹æ•°é‡:', allStations.length);
            console.log('ç«™ç‚¹åˆ—è¡¨:', allStations);
        }

        // æ£€æŸ¥æ—¶é—´
        function checkTime() {
            if (currentRoutes.length === 0) {
                alert('è¯·å…ˆé€‰æ‹©äº¤é€šæ–¹å¼å¹¶æŸ¥çœ‹è·¯çº¿');
                return;
            }

            // æ˜¾ç¤ºç«™ç‚¹é€‰æ‹©æ¨¡æ€æ¡†
            const modal = document.getElementById('stationModal');
            const select = document.getElementById('stationSelect');
            
            // æ¸…ç©ºå¹¶å¡«å……ç«™ç‚¹é€‰é¡¹
            select.innerHTML = '<option value="">è¯·é€‰æ‹©ç«™ç‚¹</option>';
            allStations.forEach(station => {
                const option = document.createElement('option');
                option.value = station.name;
                option.textContent = `${station.type === 'subway' ? 'ğŸš‡' : 'ğŸšŒ'} ${station.line}: ${station.name}`;
                option.dataset.station = JSON.stringify(station);
                select.appendChild(option);
            });

            modal.style.display = 'block';
            document.getElementById('resultMessage').classList.add('hidden');
        }

        // è®¡ç®—æ—¶é—´
        function calculateTime() {
            const selectedStation = document.getElementById('stationSelect').value;
            const currentTime = document.getElementById('currentTime').value;
            
            if (!selectedStation) {
                alert('è¯·é€‰æ‹©æ‚¨å½“å‰æ‰€åœ¨çš„ç«™ç‚¹');
                return;
            }

            if (!selectedRoute) {
                alert('è¯·å…ˆé€‰æ‹©ä¸€æ¡è·¯çº¿');
                return;
            }

            const resultDiv = document.getElementById('resultMessage');
            resultDiv.classList.remove('hidden', 'success', 'warning', 'danger');

            // è§£ææ—¶é—´
            const [currentHour, currentMinute] = currentTime.split(':').map(Number);
            const [targetHour, targetMinute] = targetTime.split(':').map(Number);
            
            const currentMinutes = currentHour * 60 + currentMinute;
            const targetMinutes = targetHour * 60 + targetMinute;

            // å¦‚æœå·²ç»è¶…è¿‡9ç‚¹
            if (currentMinutes >= targetMinutes) {
                resultDiv.className = 'result-message danger';
                resultDiv.textContent = 'ä½ å·²ç»è¿Ÿåˆ°äº†ï¼';
                // è®¡ç®—å‰©ä½™æ—¶é—´
                if (selectedRoute) {
                    const remainingTime = calculateRemainingTime(selectedStation, selectedRoute);
                    resultDiv.textContent += ` ç»§ç»­æŒ‰åŸè·¯çº¿è¿˜éœ€ ${remainingTime} åˆ†é’Ÿåˆ°è¾¾ã€‚`;
                }
                return;
            }

            // è®¡ç®—å‰©ä½™æ—¶é—´
            const remainingMinutes = targetMinutes - currentMinutes;
            const routeRemainingTime = calculateRemainingTime(selectedStation, selectedRoute);

            if (routeRemainingTime <= remainingMinutes) {
                resultDiv.className = 'result-message success';
                resultDiv.textContent = 'ä½ ä¸ä¼šè¿Ÿåˆ°ï¼Œç»§ç»­æŒ‰åŸè·¯çº¿å‰è¿›ï¼';
            } else {
                resultDiv.className = 'result-message warning';
                resultDiv.textContent = 'ä½ è¦è¿Ÿåˆ°äº†ï¼Œèµ¶å¿«å°±è¿‘æ‰“è½¦ï¼';
            }
        }

        // è®¡ç®—ä»å½“å‰ç«™ç‚¹åˆ°ç›®çš„åœ°çš„å‰©ä½™æ—¶é—´
        function calculateRemainingTime(currentStation, route) {
            if (route.type === 'driving') {
                // æ‰“è½¦è·¯çº¿ï¼Œå‡è®¾å½“å‰ä½ç½®åœ¨è·¯çº¿çš„æŸä¸ªç‚¹ï¼ˆæ¯”å¦‚å·²ç»èµ°äº†30%çš„è·¯ç¨‹ï¼‰
                return Math.round(route.duration * 0.7);
            } else {
                // å…¬äº¤/åœ°é“è·¯çº¿
                let found = false;
                let remainingStations = 0;
                let totalTime = 0;
                let foundIndex = -1;

                // é¦–å…ˆå°è¯•ä»stationsä¸­æŸ¥æ‰¾
                if (route.stations && route.stations.length > 0) {
                    for (let i = 0; i < route.stations.length; i++) {
                        const station = route.stations[i];
                        // æ£€æŸ¥ç«™ç‚¹åç§°æ˜¯å¦åŒ¹é…ï¼ˆæ”¯æŒéƒ¨åˆ†åŒ¹é…ï¼‰
                        if (station.from === currentStation || station.to === currentStation ||
                            station.from.includes(currentStation) || station.to.includes(currentStation) ||
                            currentStation.includes(station.from) || currentStation.includes(station.to)) {
                            found = true;
                            foundIndex = i;
                            // å¦‚æœåŒ¹é…çš„æ˜¯fromç«™ï¼Œè¯´æ˜è¿˜æ²¡å‡ºå‘ï¼Œéœ€è¦è®¡ç®—ä»fromåˆ°ç»ˆç‚¹çš„æ‰€æœ‰ç«™ç‚¹
                            // å¦‚æœåŒ¹é…çš„æ˜¯toç«™ï¼Œè¯´æ˜å·²ç»åˆ°è¾¾ï¼Œéœ€è¦è®¡ç®—ä»ä¸‹ä¸€ä¸ªç«™ç‚¹åˆ°ç»ˆç‚¹çš„æ‰€æœ‰ç«™ç‚¹
                            if (station.from === currentStation || station.from.includes(currentStation) || currentStation.includes(station.from)) {
                                remainingStations = route.stations.length - i;
                            } else {
                                remainingStations = route.stations.length - i - 1;
                            }
                            break;
                        }
                    }
                }

                // å¦‚æœæ²¡æ‰¾åˆ°ï¼Œå°è¯•ä»segmentsä¸­æŸ¥æ‰¾
                if (!found && route.segments && route.segments.length > 0) {
                    for (let i = 0; i < route.segments.length; i++) {
                        const segment = route.segments[i];
                        if (segment.bus && segment.bus.buslines) {
                            segment.bus.buslines.forEach(busline => {
                                if (busline.departure_stop && busline.departure_stop.name) {
                                    if (busline.departure_stop.name === currentStation || 
                                        busline.departure_stop.name.includes(currentStation) ||
                                        currentStation.includes(busline.departure_stop.name)) {
                                        found = true;
                                        foundIndex = i;
                                        // è®¡ç®—å‰©ä½™æ®µæ•°
                                        remainingStations = route.segments.length - i;
                                    }
                                }
                            });
                        } else if (segment.railway && segment.railway.lines) {
                            segment.railway.lines.forEach(line => {
                                if (line.departure_stop && line.departure_stop.name) {
                                    if (line.departure_stop.name === currentStation ||
                                        line.departure_stop.name.includes(currentStation) ||
                                        currentStation.includes(line.departure_stop.name)) {
                                        found = true;
                                        foundIndex = i;
                                        remainingStations = route.segments.length - i;
                                    }
                                }
                            });
                        }
                    }
                }

                if (found) {
                    // æ¯ç«™å¹³å‡2-3åˆ†é’Ÿï¼Œå–2.5åˆ†é’Ÿ
                    totalTime = remainingStations * 2.5;
                    // åŠ ä¸Šå¯èƒ½çš„æ­¥è¡Œæ—¶é—´ï¼ˆå‡è®¾æœ€åä¸€æ®µæ­¥è¡Œ25åˆ†é’Ÿï¼‰
                    if (remainingStations > 0) {
                        totalTime += 25;
                    }
                } else {
                    // å¦‚æœæ²¡æ‰¾åˆ°ç«™ç‚¹ï¼Œä½¿ç”¨åŸè·¯çº¿çš„æ€»æ—¶é—´ï¼ˆå‡è®¾å·²ç»èµ°äº†ä¸€åŠï¼‰
                    totalTime = Math.round(route.duration * 0.5);
                }

                return Math.round(totalTime);
            }
        }

        // å…³é—­æ¨¡æ€æ¡†
        function closeModal() {
            document.getElementById('stationModal').style.display = 'none';
        }

        // ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
        window.onclick = function(event) {
            const modal = document.getElementById('stationModal');
            if (event.target === modal) {
                closeModal();
            }
        }
    </script>
</body>
</html>

